stages:
  - versioning
  - build
  - deploy

variables:
  VERSION_BUMP:
    value: "patch"
    options: ["patch", "minor", "major"]
    description: "Art der Versionserh√∂hung f√ºr das Release."

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "web" && $VERSION_BUMP
    - if: $CI_COMMIT_TAG

# --- Stufe 1: Neue Version erstellen ---
create_new_version_tag:
  stage: versioning
  image:
    name: alpine/git:latest
    entrypoint: [""]
  rules:
    - if: $CI_PIPELINE_SOURCE == "web" && $VERSION_BUMP
  before_script:
    - git config --global user.email "gitlab-ci@example.com"
    - git config --global user.name "GitLab CI"
    - git remote set-url origin "https://gitlab-ci-token:${CI_PROJECT_ACCESS_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - |
      set -e

      echo "üì¶ Letzten Tag abrufen..."
      git fetch --tags

      TAGS=$(git tag)
      if [ -z "$TAGS" ]; then
        LATEST_TAG="v0.0.0"
        echo "‚ö†Ô∏è  Keine Tags gefunden. Fallback: $LATEST_TAG"
      else
        LATEST_TAG=$(git describe --tags $(git rev-list --tags --max-count=1))
        echo "‚úÖ Letzter Tag ist $LATEST_TAG"
      fi

      VERSION="${LATEST_TAG#v}"
      set -- $(echo "$VERSION" | tr '.' ' ')
      MAJOR=${1:-0}
      MINOR=${2:-0}
      PATCH=${3:-0}

      case "$VERSION_BUMP" in
        major)
          MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0;;
        minor)
          MINOR=$((MINOR + 1)); PATCH=0;;
        patch|*)
          PATCH=$((PATCH + 1));;
      esac

      NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
      echo "üöÄ Neue Version ist $NEW_VERSION"

      git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
      git push origin "$NEW_VERSION"
      echo "üè∑Ô∏è  Neuer Tag $NEW_VERSION wurde erfolgreich erstellt und gepusht."

# --- Stufe 2 & 3: Bauen und Deployen ---
build_image:
  stage: build
  image: docker:24.0.7
  services:
    - docker:24.0.7-dind
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - IMAGE_TAGGED_WITH_VERSION="$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG"
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    - docker build -t "$IMAGE_TAGGED_WITH_VERSION" -t "$CI_REGISTRY_IMAGE:latest" packages/docs/
    - docker push --all-tags "$CI_REGISTRY_IMAGE"

deploy_to_server:
  stage: deploy
  image: alpine:latest
  needs: [build_image]
  rules:
    - if: $CI_COMMIT_TAG
  script:
    - |
      ssh $SERVER_USER@$SERVER_IP "
        set -e 
        
        cd /opt/webapps/vorm-docs/

        echo 'üîë Login at GitLab-Registry on the server...'
        # Dies ist die korrekte, nicht-interaktive Methode
        echo "$CI_DEPLOY_PASSWORD" | docker login $CI_REGISTRY -u $CI_DEPLOY_USER --password-stdin;

        echo '‚¨áÔ∏è Get new image from registry...';
        docker compose pull;
        
        echo 'üîÑ Restart container...';
        docker compose down;
        docker compose up -d;
        
        echo 'üßπ Clean up...';
        docker image prune -f;
      "
